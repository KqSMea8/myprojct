工欲善其事必先利其器
分配任务后先去分析任务所需，了解所需内容及功能，不要急于直接完成

//============================================================
1.写代码尽量功能拆分成独立函数，方便管理

2.将函数尽量写成一个类，便于理解

3.多使用系统函数，简介易懂

//============================================================
1.函数前面加 ”::“ 指调用的是全局函数

2.explict关键字只需用于雷内的单参数构造函数前面。由于无参的构造函数总是显示调用，这种情况在构造函数前面加explict无意义

3.override关键子，如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译

4.注意点：写代码尽量将功能拆分成一个独立的函数，方便管理

5.const修饰符
5.1.如果参数做输出用，不论它是什么数据类型，也不论它采用"指针传递"还是"引用传递"，都不能加const修饰，否则该参数将失去输出功能。const只能修饰输入参数
5.2.如果给以“指针穿点”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针，
    如果函数参数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值
5.3.任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时。不慎修改了数据成员，或者调用了其他非const成员函数，编译器将指出错误。
5.4.const int* pone;//只想整形常亮的指针，它只想的值不能修改
    int const* ptwo;//指向整形的常量指针，它不能在指向别的变量，单指向（变量）的值可以修改

6.static修饰符
6.1.static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化。因为static是所有对象共享的变量，必须要比对象先存在。
6.2.由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能范文static修饰的类成员

7.强制类型转换
7.1.const_cast一般用于强制消除对象的常量属性
7.2.static_cast 
    1)用于基本数据类型的转换，如把int装换为char
    2)把空指针转换成目标类型的空指针
    3)把任何类型的表达式类型转换成void类型
    4)用于类层次结构中父类和子类之间指针和引用的转换
7.3.dynamic_casr主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下转换的安全性，何为安全性？即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL，之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL，对于上行转换，dynamic_cast和static_cast是一样的

8.智能指针
8.1.shared_ptr多个指针指向相同的对象。shared_ptr使用引用技术，每一个shared_ptr的拷贝都指向相同的内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁
8.2.unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象(通过禁止拷贝语义、只有移动语义来实现)。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁
8.3.weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测全。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加

9.enum 传统的enum关键字的作用域是全局的，也就是说，如果在enum A 中生命一个枚举类型，无法在enum B 中声明同样的枚举类型
eg 
enum A {my_enum3 = 0};
enum B {my_enum3 = 0};//是错误的
9.1.如下面这样声明和定义枚举就是正确的，要访问A和B中的枚举是需要加上作用域的
eg
enum class A {my_enum3 = 0};
enum class B {my_enum3 = 0};
enum c {my_enum3 = 0};
A a = A::my_enum3;
B b = B::my_enum3;
9.2.可以指定底层数据类型
eg
enum class A: int //每个枚举都是int类型的
{
    my_enum3 = 0;
}
enum class B: unsigned char //每个枚举都是unsigned char类型的
{
    my_enum3 = 0;
}
//============================================================